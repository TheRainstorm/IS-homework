## PlanA

1. 选择一个简单的$y^2 = x^3 + ax + b$，(a, b, p)较小，且满足约束$9a^3+27b^2 \ne 0\ ({\rm mod\ p})$。

   为了求得初始点，这里固定b=1，保证(0, 1)在椭圆曲线上。

2. 生成椭圆曲线上的所有点坐标。（枚举法，双重for循环）

   从第一个点P开始，依次求2P...nP。（~~不知道能~~不能生成所有的点）

3. 模拟加密传输过程。

   1. 选择一个私钥k，生成公钥(P, G)。G=kP，P可以为(0, 1)
   2. 发送方选择接收方的公钥，再随机选择一个随机数r，发送消息：(A=M+rG, B=rP)。接收方计算A +(- kB) = M。

4. 将一个字节编码到坐标。（也可以是半个字节甚至1bit）

   $x \rightarrow (x+1){\rm P}$，其中$x \in [0, 255]$，代表一个字节。

## algorithm

1. 求P+G涉及到求模的逆，即已知m和p, 求x使得：
   $$
   mx = 1\ {\rm mod\ p}
   $$
   使用欧几里得算法可以计算两个数a, b的最大公因子gcd(a, b)，也可以同时求得不定方程:
   $$
   ax+by=gcd(a, b)
   $$
   的一个解。而mx+py = 1的一个解x即为$m^{-1}$。

   算法代码：

   ```python
   def gcd_and_xy(a, b):
       '''use Euclid Algorithm to cacluate:
           1. gcd(a, b)
           2. ax + by = gcd(a, b), the one of (x, y)
       '''
       x1, y1 = 1, 0
       x2, y2 = 0, 1
   
       r = b
       x3, y3 = 0, 1
       while a%b!=0:
           q, r = a//b, a%b
           x3, y3 = x1 - q*x2, y1 - q*y2
   
           a, b = b, r     # shift right
           x1, x2 = x2, x3
           y1, y2 = y2, y3
       return r, (x3, y3)
   ```

2. 获得较大的素数：

   形如$M_n = 2^n-1$的素数称为梅森素数。

   一些已知的n值如下：

   2,3,5,7,13,17,19,31,61,89,107,127,521,607,1279,2203,2281,
   
   3217,4253,4423,9689,9941...
